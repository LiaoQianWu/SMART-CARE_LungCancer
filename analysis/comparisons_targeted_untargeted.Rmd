---
title: "Comparisons between targeted and untargeted datasets"
author: "Qian-Wu Liao"
output:
  workflowr::wflow_html:
    toc: true
    toc_float: true
    code_folding: hide
---

<font size='4'> Description: Compare Targeted and Untargeted Plasma and Tissue
Metabolomics generated by AG Hell and AG Hopf, respectively. This report mainly
looks into if Targeted and Untargeted data can provide complementary information
or more or less same information. To this purpose, we computed correlations between
Recurrence-related PCs learned from paired datasets (e.g., Targeted Plasma Metabolomics
vs Untargeted Plasma Metabolomics) and between Targeted and Untargeted features.
Furthermore, we leveraged MOFA model to see if there are same sources of variation
in paired datasets. Note that only results of Baseline samples are discussed since
predicting cancer recurrence is of most interest. </font>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.height = 8, fig.width = 10, warning = F)
knitr::opts_knit$set(root.dir = '/Users/qianwu/Desktop/SMART-CARE_LungCancer_MethodDev')
```

Load libraries
```{r library loading, message = F}
library(MOFA2)
library(reticulate)
use_python('/Users/qianwu/opt/anaconda3/bin/python')
library(SummarizedExperiment)
library(ggrepel)
library(ggfortify)
library(igraph)
library(ggraph)
library(ggVennDiagram)
library(tidyverse)
# Load user-defined functions
source('./code/misc.R')
```

# PC correlations

Display associations between learned PCs (Var1) and patient cancer recurrence (Var2).
Basically t-test was performed to test significance of difference between recurrence
and non-recurrence patient groups.\
<br/>
<font size='4'> Targeted Metabolomics from AG Hell </font>\
**Baseline Plasma Metabolomics**
```{r}
# Baseline Plasma Metabolomics
# Load normalized data
metaPlasma_Hell <- readRDS('./data/AG_Hell/metaPlasmaNorm.rds')
# Subset baseline samples
smpBaseIdx <- which(colData(metaPlasma_Hell)$Condition == 'Baseline')
metaBase_Hell <- metaPlasma_Hell[, smpBaseIdx]

# Perform analysis
metaBaseRes_Hell <- SOA(metaBase_Hell, fac = 'Recurrence', num_feats = 42)
tPCASigRes <- metaBaseRes_Hell$tPCASigRes

# Display PCs that can significantly separate recurrence and non-recurrence
# patients
tPCASigRes
```

**Tumor Tissue Metabolomics**
```{r}
# Tumor Tissue Metabolomics
# Load normalized data
metaTissue_Hell <- readRDS('./data/AG_Hell/metaTissueNorm.rds')
# Subset baseline samples
smpTumorIdx <- which(colData(metaTissue_Hell)$Condition == 'Tumor')
metaTumor_Hell <- metaTissue_Hell[, smpTumorIdx]

# Perform analysis
metaTumorRes_Hell <- SOA(metaTumor_Hell, fac = 'Recurrence', num_feats = 30)
tPCASigRes <- metaTumorRes_Hell$tPCASigRes

# Display PCs that can significantly separate recurrence and non-recurrence
# patients
tPCASigRes
```

**Normal Tissue Metabolomics**
```{r}
# Normal Tissue Metabolomics
# Subset baseline samples
smpNormalIdx <- which(colData(metaTissue_Hell)$Condition == 'Normal')
metaNormal_Hell <- metaTissue_Hell[, smpNormalIdx]

# Perform analysis
metaNormalRes_Hell <- SOA(metaNormal_Hell, fac = 'Recurrence', num_feats = 30)
tPCASigRes <- metaNormalRes_Hell$tPCASigRes

# Display PCs that can significantly separate recurrence and non-recurrence
# patients
tPCASigRes
```
<br/>
<br/>

<font size='4'> Untargeted Metabolomics from AG Hopf </font>\
<br/>
**Baseline Plasma Metabolomics**\
There is no Recurrence-related PC learned.
```{r}
# Baseline Plasma Metabolomics
# Load normalized data
metaPlasma_Hopf <- readRDS('./data/AG_Hopf/metaPlasmaVsn.rds')
# Retrieve sample information for matching sample names
smpAnno <- tibble::as_tibble(colData(metaPlasma_Hell), rownames = 'Sample') %>%
  dplyr::mutate(Identifier = stringr::str_remove(Identifier, '_3$')) %>%
  dplyr::select(Sample, Identifier)
colnames(metaPlasma_Hopf) <- plyr::mapvalues(colnames(metaPlasma_Hopf),
                                             from = smpAnno$Identifier,
                                             to = smpAnno$Sample)
# Subset baseline samples
smpBaseIdx <- which(colData(metaPlasma_Hopf)$Condition == 'Baseline')
metaBase_Hopf <- metaPlasma_Hopf[, smpBaseIdx]

# Perform analysis
metaBaseRes_Hopf <- SOA(metaBase_Hopf, fac = 'Recurrence', num_feats = 90)
tPCASigRes <- metaBaseRes_Hopf$tPCASigRes
pcaRes <- metaBaseRes_Hopf$pcaRes
datMat <- metaBaseRes_Hopf$data
smpAnno <- metaBaseRes_Hopf$smpMetadata

# Display PCs that can significantly separate recurrence and non-recurrence
# patients
tPCASigRes

# Use probabilistic dropout model to account for missing values and identify
# differentially abundant entities
# Fit linear probabilistic dropout model to normalized data
fit <- proDA::proDA(datMat, design = ~ smpAnno$Recurrence)
# Identify significant differentially abundant entities
proDAMetaBaseSigFeats <- proDA::test_diff(fit,
                                          contrast = Intercept + `smpAnno$RecurrenceYes` - Intercept,
                                          sort_by = 'pval') %>%
  dplyr::select(-c(diff, se, df, avg_abundance, n_approx)) %>%
  dplyr::filter(pval < 0.05)
```

**Tumor Tissue Metabolomics**
```{r}
# Tumor Tissue Metabolomics
# Load normalized data
metaTissue_Hopf <- readRDS('./data/AG_Hopf/metaTissueVsn.rds')
# Subset baseline samples
smpTumorIdx <- which(colData(metaTissue_Hopf)$Condition == 'Tumor')
metaTumor_Hopf <- metaTissue_Hopf[, smpTumorIdx]

# Perform analysis
metaTumorRes_Hopf <- SOA(metaTumor_Hopf, fac = 'Recurrence', num_feats = 30)
tPCASigRes <- metaTumorRes_Hopf$tPCASigRes
datMat <- metaTumorRes_Hopf$data
smpAnno <- metaTumorRes_Hopf$smpMetadata

# Display PCs that can significantly separate recurrence and non-recurrence
# patients
tPCASigRes

# Use probabilistic dropout model to account for missing values and identify
# differentially abundant entities
# Fit linear probabilistic dropout model to normalized data
fit <- proDA::proDA(datMat, design = ~ smpAnno$Recurrence)
# Identify significant differentially abundant entities
proDAMetaTumorSigFeats <- proDA::test_diff(fit,
                                           contrast = Intercept + `smpAnno$RecurrenceYes` - Intercept,
                                           sort_by = 'pval') %>%
  dplyr::select(-c(diff, se, df, avg_abundance, n_approx)) %>%
  dplyr::filter(pval < 0.05)
```

**Normal Tissue Metabolomics**\
There is no Recurrence-related PC learned.
```{r}
# Normal Tissue Metabolomics
# Subset baseline samples
smpNormalIdx <- which(colData(metaTissue_Hopf)$Condition == 'Normal')
metaNormal_Hopf <- metaTissue_Hopf[, smpNormalIdx]

# Perform analysis
metaNormalRes_Hopf <- SOA(metaNormal_Hopf, fac = 'Recurrence', num_feats = 30)
tPCASigRes <- metaNormalRes_Hopf$tPCASigRes
datMat <- metaNormalRes_Hopf$data
smpAnno <- metaNormalRes_Hopf$smpMetadata

# Display PCs that can significantly separate recurrence and non-recurrence
# patients
tPCASigRes

# Use probabilistic dropout model to account for missing values and identify
# differentially abundant entities
# Fit linear probabilistic dropout model to normalized data
fit <- proDA::proDA(datMat, design = ~ smpAnno$Recurrence)
# Identify significant differentially abundant entities
proDAMetaNormalSigFeats <- proDA::test_diff(fit,
                                            contrast = Intercept + `smpAnno$RecurrenceYes` - Intercept,
                                            sort_by = 'pval') %>%
  dplyr::select(-c(diff, se, df, avg_abundance, n_approx)) %>%
  dplyr::filter(pval < 0.05)
```
<br/>
<br/>

Visualize correlations of Recurrence-related PCs learned from Targeted and Untargeted
data to see if same sources of variation are captured by different methods\
<br/>
**Targeted Tumor Tissue Metabolomics vs Untargeted TTM**
```{r}
# <font size='4'> Original Untargeted data with missing values </font>\

# TTM_Hell vs TTM_Hopf
# Extract significant PCs from different datasets and combine needed information
# into a table
metaTumorSigPC_Hell <- dplyr::select(metaTumorRes_Hell$pcTab, c(Sample, PC16))
metaTumorSigPC_Hopf <- dplyr::select(metaTumorRes_Hopf$pcTab, c(Sample, PC5, Recurrence))
metaTumorSigPC <- dplyr::left_join(metaTumorSigPC_Hell, metaTumorSigPC_Hopf, by = 'Sample')
# Compute correlations between significant PCs
cat('Correlation between Targeted TTM PC16 and Untargeted TTM PC5 is',
    stats::cor.test(metaTumorSigPC$PC16, metaTumorSigPC$PC5,
                    method = 'pearson', use = "pairwise.complete.obs")$estimate)
```

```{r include = F, eval = F}
# <font size='4'> Imputed Untargeted data using MissForest algorithm </font>\
# <br/>
# **Targeted TTM vs Imputed Untargeted TTM**\
# Display Recurrence-related PC learned from imputed Untargeted TTM dataset

# Load imputed data
impuMetaTumor_Hopf <- readRDS('./data/AG_Hopf/impuByMF/impuTTM_Hopf.rds')
# Conduct PCA
impuMetaTumorRes_Hopf <- SOA(impuMetaTumor_Hopf, factor = 'Recurrence')
impuMetaTumorRes_Hopf$tPCASigRes

# TTM_Hell vs imputed TTM_Hopf
# Extract significant PCs and combine needed information into a table
metaTumorSigPC_Hell <- dplyr::select(metaTumorRes_Hell$pcTab, c(Sample, PC16)) %>%
  dplyr::mutate(Sample = stringr::str_remove(Sample, '_.*'))
impuMetaTumorSigPC_Hopf <- dplyr::select(impuMetaTumorRes_Hopf$pcTab,
                                         c(Sample, PC6, Recurrence)) %>%
  dplyr::mutate(Sample = stringr::str_remove(Sample, '_.*'))
metaTumorSigPC <- dplyr::left_join(metaTumorSigPC_Hell, impuMetaTumorSigPC_Hopf,
                                   by = 'Sample')
# Compute correlations between significant PCs
cat('Correlation between Targeted TTM PC16 and Imputed Untargeted TTM PC6 is',
    stats::cor.test(metaTumorSigPC$PC16, metaTumorSigPC$PC6,
                    method = 'pearson', use = "pairwise.complete.obs")$estimate)


# **Untargeted TTM vs Imputed Untargeted TTM**

# TTM_Hopf vs imputed TTM_Hopf
# Extract significant PCs and combine needed information into a table
metaTumorSigPC_Hopf <- dplyr::select(metaTumorRes_Hopf$pcTab, c(Sample, PC6)) %>%
  dplyr::mutate(Sample = stringr::str_remove(Sample, '_.*'))
impuMetaTumorSigPC_Hopf <- dplyr::select(impuMetaTumorRes_Hopf$pcTab,
                                         c(Sample, PC6, Recurrence)) %>%
  dplyr::mutate(Sample = stringr::str_remove(Sample, '_.*')) %>%
  dplyr::rename(impuPC6 = PC6)
metaTumorSigPC <- dplyr::left_join(metaTumorSigPC_Hopf, impuMetaTumorSigPC_Hopf,
                                   by = 'Sample')
# Compute correlations between significant PCs
cat('Correlation between Untargeted TTM PC6 and Imputed Untargeted TTM PC6 is',
    stats::cor.test(metaTumorSigPC$PC6, metaTumorSigPC$impuPC6,
                    method = 'pearson', use = "pairwise.complete.obs")$estimate)

# Display relationship between significant PCs
ggplot(metaTumorSigPC, aes(x=PC6, impuPC6, col=Recurrence)) +
  geom_point(size = 4) +
  ggpubr::stat_cor(aes(label=after_stat(r.label)),
                   method = 'pearson', size = 5, color = 'black') +
  stat_smooth(formula = y ~ x, method = "lm", color = "grey", alpha = 0.2) +
  labs(x = 'PC6 (Untargeted TTM)', y = 'PC6 (Untargeted & Imputed TTM)') +
  scale_color_manual(values=c('#00BFC4', '#F8766D')) +
  scale_fill_manual(values=c('#00BFC4', '#F8766D'))


# **Targeted Normal Tissue Metabolomics vs Imputed Untargeted NTM**\
# Display Recurrence-related PCs learned from imputed Untargeted NTM dataset

# NTM_Hell
# Extract significant PCs
metaNormalSigPC_Hell <- dplyr::select(metaNormalRes_Hell$pcTab,
                                      c(Sample, PC6, PC17, PC9))
# Computed correlations between significant PCs
# stats::cor.test(metaNormalSigPC_Hell$PC6, metaNormalSigPC_Hell$PC17,
#                 method = 'pearson', use = "pairwise.complete.obs")$estimate
# stats::cor.test(metaNormalSigPC_Hell$PC6, metaNormalSigPC_Hell$PC9,
#                 method = 'pearson', use = "pairwise.complete.obs")$estimate

# Load imputed data
impuMetaNormal_Hopf <- readRDS('./data/AG_Hopf/impuByMF/impuNTM_Hopf.rds')
# Conduct PCA
impuMetaNormalRes_Hopf <- SOA(impuMetaNormal_Hopf, factor = 'Recurrence')
impuMetaNormalRes_Hopf$tPCASigRes

# NTM_Hell vs imputed NTM_Hopf
# Extract significant PCs and combine needed information into a table
metaNormalSigPC_Hell <- dplyr::mutate(metaNormalSigPC_Hell,
                                      Sample = stringr::str_remove(Sample, '_.*'))
impuMetaNormalSigPC_Hopf <- dplyr::select(impuMetaNormalRes_Hopf$pcTab,
                                          c(Sample, PC10, PC14)) %>%
  dplyr::mutate(Sample = stringr::str_remove(Sample, '_.*'))
metaNormalSigPC <- dplyr::left_join(metaNormalSigPC_Hell, impuMetaNormalSigPC_Hopf,
                                    by = 'Sample')
# Computed correlations between significant PCs
cat('Correlation between Targeted PC6 and Imputed Untargeted PC10 is',
    stats::cor.test(metaNormalSigPC_Hell$PC6, impuMetaNormalSigPC_Hopf$PC10,
                    method = 'pearson', use = "pairwise.complete.obs")$estimate)
cat('Correlation between Targeted PC6 and Imputed Untargeted PC14 is',
    stats::cor.test(metaNormalSigPC_Hell$PC6, impuMetaNormalSigPC_Hopf$PC14,
                    method = 'pearson', use = "pairwise.complete.obs")$estimate)
cat('Correlation between Targeted PC17 and Imputed Untargeted PC10 is',
    stats::cor.test(metaNormalSigPC_Hell$PC17, impuMetaNormalSigPC_Hopf$PC10,
                    method = 'pearson', use = "pairwise.complete.obs")$estimate)
cat('Correlation between Targeted PC17 and Imputed Untargeted PC14 is',
    stats::cor.test(metaNormalSigPC_Hell$PC17, impuMetaNormalSigPC_Hopf$PC14,
                    method = 'pearson', use = "pairwise.complete.obs")$estimate)
cat('Correlation between Targeted PC9 and Imputed Untargeted PC10 is',
    stats::cor.test(metaNormalSigPC_Hell$PC9, impuMetaNormalSigPC_Hopf$PC10,
                    method = 'pearson', use = "pairwise.complete.obs")$estimate)
cat('Correlation between Targeted PC9 and Imputed Untargeted PC14 is',
    stats::cor.test(metaNormalSigPC_Hell$PC9, impuMetaNormalSigPC_Hopf$PC14,
                    method = 'pearson', use = "pairwise.complete.obs")$estimate)
# cat('Correlation between Imputed Targeted PC10 and Imputed Untargeted PC14 is',
#     stats::cor.test(impuMetaNormalSigPC_Hopf$PC10, impuMetaNormalSigPC_Hopf$PC14,
#                     method = 'pearson', use = "pairwise.complete.obs")$estimate)


# Load imputed data
impuMetaBase_Hopf <- readRDS('./data/AG_Hopf/impuByMF/impuBPM_Hopf.rds')
# Conduct PCA
# impuMetaBaseRes_Hopf <- SOA(impuMetaBase_Hopf, factor = 'Recurrence')
# impuMetaBaseRes_Hopf$tPCASigRes

# => Generally, correlations of Recurrence-related PCs between Targeted and (Imputed)
# Untargeted datasets are low, indicating that Targeted and Untargeted data may carry
# different information in terms of predicting cancer recurrence. However, cannot
# say if MissForest algorithm is reliable for imputing missing values. Theoretically,
# MissForest should be good at handling MAR (missing at random), yet we assume much
# of missingness in our data is due to extremely small values (MNAR, missing not at
# random) that machine fails to detect. Therefore, it might also be that too much
# information is removed from Untargeted datasets when conducting PCA and imputated
# values are not biologically accurate, leading to uncorrelated results between Targeted
# and Untargeted datasets.
```
=> Correlation of Recurrence-related PCs between Targeted and Untargeted Tumor Tissue
Metabolomics are low, indicating that these two datasets may carry different information
in terms of predicting cancer recurrence. Yet, it may also be that too much information
is removed from Untargeted datasets since PCA does not use features with missing
data, leading to unreliable Recurrence-related PC. Maybe same missing data issue
also cause that Untargeted Baseline Plasma Metabolomics and Untargeted Normal Tissue
Metabolomics fail to learn Recurrence-related PCs.




# Feature correlations
One purpose is to see if Untargeted features defined by m/z and retention time
can be identified by Targeted features.

## Plasma Metabolites
<font size='5'> **Untargeted vs Targeted Plasma Metabolites** </font>\
Systematically compute correlations of all feature pairs where two features are
from paired datasets, i.e., Targeted and Untargeted Plasma Metabolomics. Note that
both Baseline and Follow-up samples were used.
<br/>
<br/>

Show correlations between features through heatmap
```{r}
# Load normalized data
metaPlasma_Hopf <- readRDS('./data/AG_Hopf/metaPlasmaVsn.rds')
metaPlasma_Hell <- readRDS('./data/AG_Hell/metaPlasmaNorm.rds')
# Retrieve sample information for matching sample names for two datasets
smpAnno <- tibble::as_tibble(colData(metaPlasma_Hell), rownames = 'Sample') %>%
  dplyr::mutate(Identifier = stringr::str_remove(Identifier, '_3$')) %>%
  dplyr::select(Sample, Identifier)
# Extract data matrix
datMat_Hopf <- SummarizedExperiment::assay(metaPlasma_Hopf)
datMat_Hell <- SummarizedExperiment::assay(metaPlasma_Hell)
# Transpose data for systematically computing correlations between features
featTab_Hopf <- t(datMat_Hopf) %>%
  tibble::as_tibble(rownames = 'Sample') %>%
  dplyr::mutate(Sample = plyr::mapvalues(Sample, from = smpAnno$Identifier,
                                         to = smpAnno$Sample))
featTab_Hell <- t(datMat_Hell) %>%
  tibble::as_tibble(rownames = 'Sample')

# Systematically compute correlations between untargeted feature pairs
# corrMetaPlasmaRes_Hopf_Hell <- corrIter(featTab_Hopf, featTab_Hell, cmn_col = 'Sample')
# saveRDS(corrMetaPlasmaRes_Hopf_Hell, './data/corrMetaPlasmaRes_Hopf_Hell.rds')
corrMetaPlasmaRes_Hopf_Hell <- readRDS('./data/corrMetaPlasmaRes_Hopf_Hell.rds')

# Convert long data to wide data
corrMat <- dplyr::select(corrMetaPlasmaRes_Hopf_Hell, Var1, Var2, Corr) %>%
  tidyr::pivot_wider(names_from = 'Var2', values_from = 'Corr') %>%
  tibble::column_to_rownames('Var1')

# Make heatmap
a <- pheatmap::pheatmap(corrMat, show_rownames = F, show_colnames = F,
                   color = colorRampPalette(c('navy', 'white', 'red'))(100),
                   breaks = seq(-1, 1, by = 0.02))
# ggsave(paste0(result_path, 'metaPlasma_heatmap_feat_corr_Hopf_Hell.png'), a,
#        device = 'png', dpi = 400)
```

Show only highly positively correlated feature pairs through network plot. Cutoff
is (1) correlations greater than 0.7 and (2) p-values less than 0.05.
```{r fig.height = 12, fig.width = 14}
# Prepare edge table
edges <- dplyr::filter(corrMetaPlasmaRes_Hopf_Hell, Corr > 0.7, pVal < 0.05) %>%
  dplyr::select(Var1, Var2, Corr)

# Prepare node table
feats <- unique(c(edges$Var1, edges$Var2))
nodes <- data.frame(id = seq_len(length(feats)), Feature = feats,
                    From = c(rep('AG Hopf', length(unique(edges$Var1))),
                             rep('AG Hell', length(unique(edges$Var2)))))

# Map features in edge table to corresponding IDs
edges$Var1 <- plyr::mapvalues(edges$Var1, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)
edges$Var2 <- plyr::mapvalues(edges$Var2, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)
# Map Feature_ID from AG Hopf to m/z_RT
featAnno <- tibble::as_tibble(rowData(metaPlasma_Hopf), rownames = 'Feature_ID')
nodes <- dplyr::mutate(nodes, Feature = plyr::mapvalues(Feature,
                                                        from = featAnno$Feature_ID,
                                                        to = featAnno$m.z_RT,
                                                        warn_missing = F))

# Create igraph object for plotting
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

# Make network plot
ggraph(g, layout = 'fr') + #layout = 'auto'
  geom_edge_link(aes(alpha=Corr), edge_width = 1) +
  geom_node_point(size = 3) +
  geom_node_text(aes(label=Feature, color=From), repel = T, size = 3.5) +
  theme_void() +
  scale_edge_alpha_continuous(name = 'Correlation') +
  scale_color_manual(values = c('firebrick', 'steelblue'))
# ggsave('./output/network_tar_untar_PM.png', device = 'png', dpi = 400, height = 10, width = 10)
```

<font size='5'>**Untargeted Plasma Metabolites** </font>\
Systematically compute correlations of all feature pairs in Untargeted (Baseline)
Plasma Metabolomics. There are 43 out of 974 Baseline features that can potentially
predict patient cancer recurrences. Since features (defined by m/z and retention
time) in this dataset have not yet been identified through database search, there
might be a large number of highly correlated features.
<br/>
<br/>

**Use only Baseline samples to compute feature correlations**\
```{r}
# Load normalized data
metaPlasma_Hopf <- readRDS('./data/AG_Hopf/metaPlasmaVsn.rds')
# Subset Baseline plasma samples
baseSmp <- colData(metaPlasma_Hopf)[['Condition']] == 'Baseline'
metaBase_Hopf <- metaPlasma_Hopf[, baseSmp]
# Extract data matrix
datMat_Hopf <- SummarizedExperiment::assay(metaBase_Hopf)
# Transpose data for systematically computing correlations between features
featTab <- t(datMat_Hopf) %>%
  tibble::as_tibble(rownames = 'Sample')

# Systematically compute correlations between untargeted feature pairs
# corrMetaBaseRes_Hopf <- corrIter(featTab, featTab, cmn_col = 'Sample')
# saveRDS(corrMetaBaseRes_Hopf, './data/AG_Hopf/corrMetaBaseRes_Hopf.rds')
corrMetaBaseRes_Hopf <- readRDS('./data/AG_Hopf/corrMetaBaseRes_Hopf.rds')

# Convert long data to wide data
corrMat <- dplyr::select(corrMetaBaseRes_Hopf, Var1, Var2, Corr) %>%
  dplyr::mutate(Var1 = stringr::str_remove(Var1, '\\.x'),
                Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  tidyr::pivot_wider(names_from = 'Var2', values_from = 'Corr') %>%
  tibble::column_to_rownames('Var1')

# Make heatmap
# pheatmap::pheatmap(corrMat, show_rownames = F, show_colnames = F,
#                    color = colorRampPalette(c('navy', 'white', 'red'))(100))
```

Show highly positively correlated feature pairs through network plot. Cutoff is
(1) correlations greater than 0.9 and (2) adjusted p-values less than 0.05. Red
dots indicate Recurrence-related features captured in Baseline samples. There are
27 (out of 43) significant features here.
```{r fig.height = 12, fig.width = 14}
# Prepare node table
nodes <- data.frame(id = seq_len(nrow(datMat_Hopf)),
                    Feature_ID = paste0('Feature', seq_len(nrow(datMat_Hopf)))) %>%
  dplyr::mutate(Sig = dplyr::case_when(
    Feature_ID %in% proDAMetaBaseSigFeats$name ~ 'Yes',
    !Feature_ID %in% proDAMetaBaseSigFeats$name ~ 'No'))
# Append m/z_RT information
featAnno <- tibble::as_tibble(rowData(metaBase_Hopf), rownames = 'Feature_ID')
nodes <- dplyr::left_join(nodes, featAnno, by = 'Feature_ID')

# Prepare edge table
edges <- dplyr::mutate(corrMetaBaseRes_Hopf,
                       Var1 = stringr::str_remove_all(Var1, '[Feature\\.x]'),
                       Var2 = stringr::str_remove_all(Var2, '[Feature\\.y]')) %>%
  dplyr::filter(Corr > 0.9, pValAdj < 0.05, Var1 != Var2) %>%
  # Remove duplicated variable pairs
  dplyr::rowwise() %>%
  dplyr::mutate(varPair = paste(sort(c(Var1, Var2)), collapse = '')) %>%
  dplyr::distinct(varPair, .keep_all = T) %>%
  dplyr::select(Var1, Var2, Corr)
# Remove nodes without any connection
incluFeats <- unique(c(edges$Var1, edges$Var2))
nodes <- nodes[nodes$id %in% incluFeats,]

# Create igraph object for plotting
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

# Make network plot
ggraph(g, layout = 'fr') + #layout = 'auto'
  geom_edge_link(aes(alpha=Corr), edge_width = 1) +
  geom_node_point(aes(color=Sig), size = 3, show.legend = F) +
  geom_node_text(aes(label=m.z_RT), repel = T, size = 1.5) +
  theme_void() +
  scale_edge_alpha_continuous(name = 'Correlation') +
  scale_color_manual(values = c('black', 'firebrick'))
# ggsave(paste0(result_path, 'AG_Hopf/metaBase_network_feat_corr.png'),
#        height = 10, width = 11, device = 'png', dpi = 400)
```

**Use both Baseline and Follow-up samples to compute feature correlations**\
Show correlations between features through heatmap
```{r}
# Load normalized data
metaPlasma_Hopf <- readRDS('./data/AG_Hopf/metaPlasmaVsn.rds')
# Extract data matrix
datMat_Hopf <- SummarizedExperiment::assay(metaPlasma_Hopf)
# Transpose data for systematically computing correlations between features
featTab <- t(datMat_Hopf) %>%
  tibble::as_tibble(rownames = 'Sample')
# Retrieve feature information for annotating those duplicated features
# featAnno <- tibble::as_tibble(rowData(metaPlasma_Hopf), rownames = 'Feature_ID')
# featAnno['Dup_feat'] <- 'The others'
# featAnno$Dup_feat[featAnno$m.z_RT == '226.95134/0.21'] <- '226.95134/0.21'
# featAnno$Dup_feat[featAnno$m.z_RT == '362.92618/0.79'] <- '362.92618/0.79'
# featAnno$Dup_feat[featAnno$m.z_RT == '182.06326/6.18'] <- '182.06326/6.18'
# featAnno <- dplyr::select(featAnno, -m.z_RT) %>%
#   tibble::column_to_rownames('Feature_ID')

# Systematically compute correlations between untargeted feature pairs
# corrMetaPlasmaRes_Hopf <- corrIter(featTab, featTab, cmn_col = 'Sample')
# saveRDS(corrMetaPlasmaRes_Hopf, './data/AG_Hopf/corrMetaPlasmaRes_Hopf.rds')
corrMetaPlasmaRes_Hopf <- readRDS('./data/AG_Hopf/corrMetaPlasmaRes_Hopf.rds')

# Convert long data to wide data
corrMat <- dplyr::select(corrMetaPlasmaRes_Hopf, Var1, Var2, Corr) %>%
  dplyr::mutate(Var1 = stringr::str_remove(Var1, '\\.x'),
                Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  tidyr::pivot_wider(names_from = 'Var2', values_from = 'Corr') %>%
  tibble::column_to_rownames('Var1')

# Make heatmap
a <- pheatmap::pheatmap(corrMat, show_rownames = F, show_colnames = F,
                   color = colorRampPalette(c('navy', 'white', 'red'))(100))
# ggsave(paste0(result_path, 'AG_Hopf/metaPlasma_heatmap_feat_corr.png'), a,
#        device = 'png', dpi = 400)

# Show heatmap where features are ordered according to m/z ratio and retention time
# Order features
# featOrder <- factor(colnames(featTab),
#                     levels = paste0('Feature', seq_len(ncol(featTab)))) %>%
#   sort() %>%
#   as.character()
# corrMat <- corrMat[featOrder, featOrder]

# Make heatmap
# a <- pheatmap::pheatmap(corrMat, show_rownames = F, show_colnames = F,
#                    cluster_rows = F, cluster_cols = F,
#                    color = colorRampPalette(c('navy', 'white', 'red'))(100))
# ggsave(paste0(result_path, 'AG_Hopf/metaPlasma_heatmap_feat_corr2.png'), a,
#        device = 'png', dpi = 400)
```

Show only highly positively correlated feature pairs through network plot. Cutoff
is (1) correlations greater than 0.9 and (2) adjusted p-values less than 0.05.
```{r fig.height = 12, fig.width = 14}
# Prepare node table
nodes <- data.frame(id = seq_len(nrow(datMat_Hopf)),
                    Feature_ID = paste0('Feature', seq_len(nrow(datMat_Hopf))))
# Append m/z_RT information
featAnno <- tibble::as_tibble(rowData(metaPlasma_Hopf), rownames = 'Feature_ID')
nodes <- dplyr::left_join(nodes, featAnno, by = 'Feature_ID')

# Prepare edge table
edges <- dplyr::mutate(corrMetaPlasmaRes_Hopf,
                       Var1 = stringr::str_remove_all(Var1, '[Feature\\.x]'),
                       Var2 = stringr::str_remove_all(Var2, '[Feature\\.y]')) %>%
  dplyr::filter(Corr > 0.9, pValAdj < 0.05, Var1 != Var2) %>%
  # Remove duplicated variable pairs
  dplyr::rowwise() %>%
  dplyr::mutate(varPair = paste(sort(c(Var1, Var2)), collapse = '')) %>%
  dplyr::distinct(varPair, .keep_all = T) %>%
  dplyr::select(Var1, Var2, Corr)
# Remove nodes without any connection
incluFeats <- unique(c(edges$Var1, edges$Var2))
nodes <- nodes[nodes$id %in% incluFeats,]

# Create igraph object for plotting
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

# Make network plot
ggraph(g, layout = 'fr') + #layout = 'auto'
  geom_edge_link(aes(alpha=Corr), edge_width = 1) +
  geom_node_point(size = 3, show.legend = F) +
  geom_node_text(aes(label=m.z_RT), repel = T, size = 1.5) +
  theme_void() +
  scale_edge_alpha_continuous(name = 'Correlation') +
  scale_color_manual(values = c('black', 'firebrick'))
# ggsave(paste0(result_path, 'AG_Hopf/metaPlasma_network_feat_corr.png'),
#        height = 10, width = 11, device = 'png', dpi = 400)
```

<font size='5'> **Targeted Plasma Metabolites** </font>\
Systematically compute correlations of all feature pairs in Targeted (Baseline)
Plasma Metabolomics
<br/>
<br/>

**Use only Baseline samples to compute feature correlations**\
```{r}
# Load normalized data
metaPlasma_Hell <- readRDS('./data/AG_Hell/metaPlasmaNorm.rds')
# Subset Baseline plasma samples
baseSmp <- colData(metaPlasma_Hell)[['Condition']] == 'Baseline'
metaBase_Hell <- metaPlasma_Hell[, baseSmp]
# Extract data matrix
datMat_Hell <- SummarizedExperiment::assay(metaBase_Hell)
# Transpose data for systematically computing correlations between features
featTab <- t(datMat_Hell) %>%
  tibble::as_tibble(rownames = 'Sample')

# Compute correlations
# corrMetaBaseRes_Hell <- corrIter(featTab, featTab, cmn_col = 'Sample')
# saveRDS(corrMetaBaseRes_Hell, './data/AG_Hell/corrMetaBaseRes_Hell.rds')
corrMetaBaseRes_Hell <- readRDS('./data/AG_Hell/corrMetaBaseRes_Hell.rds')

# Convert long data to wide data
corrMat <- dplyr::select(corrMetaBaseRes_Hell, Var1, Var2, Corr) %>%
  dplyr::mutate(Var1 = stringr::str_remove(Var1, '\\.x'),
                Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  tidyr::pivot_wider(names_from = 'Var2', values_from = 'Corr') %>%
  tibble::column_to_rownames('Var1')

# Make heatmap
# pheatmap::pheatmap(corrMat, show_rownames = F, show_colnames = F,
#                    color = colorRampPalette(c('navy', 'white', 'red'))(100))
```

Show highly positively correlated feature pairs through network plot. Cutoff is
(1) correlations greater than 0.9 and (2) adjusted p-values less than 0.05. Red
dots indicate significant features that can predict patient cancer recurrences
found in Baseline samples. There are 18 (out of 42) significant features here.
```{r fig.height = 12, fig.width = 14}
# Prepare edge table
edges <- dplyr::mutate(corrMetaBaseRes_Hell,
                       Var1 = stringr::str_remove(Var1, '\\.x'),
                       Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  dplyr::filter(Corr > 0.9, pValAdj < 0.05, Var1 != Var2) %>%
  # Remove duplicated variable pairs
  dplyr::rowwise() %>%
  dplyr::mutate(varPair = paste(sort(c(Var1, Var2)), collapse = '')) %>%
  dplyr::distinct(varPair, .keep_all = T) %>%
  dplyr::select(Var1, Var2, Corr)

# Prepare node table
# Conduct univariate analysis to obtain significant features that can potentially
# predict patient cancer recurrences
metaBaseRes_Hell <- SOA(metaBase_Hell, factor = 'Recurrence')
feats <- unique(c(edges$Var1, edges$Var2))
nodes <- data.frame(id = seq_len(length(feats)), Feature = feats) %>%
  dplyr::mutate(Sig = dplyr::case_when(
    Feature %in% metaBaseRes_Hell$tFeatSigRes$Var1 ~ 'Yes',
    !Feature %in% metaBaseRes_Hell$tFeatSigRes$Var1 ~ 'No'))

# Map features to corresponding IDs
edges$Var1 <- plyr::mapvalues(edges$Var1, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)
edges$Var2 <- plyr::mapvalues(edges$Var2, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)

# Create igraph object for plotting
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

# Make network plot
ggraph(g, layout = 'fr') + #layout = 'auto'
  geom_edge_link(aes(alpha=Corr), edge_width = 1) +
  geom_node_point(aes(color=Sig), size = 3, show.legend = F) +
  geom_node_text(aes(label=Feature), repel = T, size = 1.5) +
  theme_void() +
  scale_edge_alpha_continuous(name = 'Correlation') +
  scale_color_manual(values = c('black', 'firebrick'))
# ggsave(paste0(result_path, 'AG_Hell/metaBase_network_feat_corr.png'),
#        height = 10, width = 11, device = 'png', dpi = 400)
```

**Use both Baseline and Follow-up samples to compute feature correlations**\
Show correlations between features through heatmap
```{r}
# Load normalized data
metaPlasma_Hell <- readRDS('./data/AG_Hell/metaPlasmaNorm.rds')
# Extract data matrix
datMat_Hell <- SummarizedExperiment::assay(metaPlasma_Hell)
# Transpose data for systematically computing correlations between features
featTab <- t(datMat_Hell) %>%
  tibble::as_tibble(rownames = 'Sample')

# Compute correlations
# corrMetaPlasmaRes_Hell <- corrIter(featTab, featTab, cmn_col = 'Sample')
# saveRDS(corrMetaPlasmaRes_Hell, './data/AG_Hell/corrMetaPlasmaRes_Hell.rds')
corrMetaPlasmaRes_Hell <- readRDS('./data/AG_Hell/corrMetaPlasmaRes_Hell.rds')

# Convert long data to wide data
corrMat <- dplyr::select(corrMetaPlasmaRes_Hell, Var1, Var2, Corr) %>%
  dplyr::mutate(Var1 = stringr::str_remove(Var1, '\\.x'),
                Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  tidyr::pivot_wider(names_from = 'Var2', values_from = 'Corr') %>%
  tibble::column_to_rownames('Var1')

# Make heatmap
a <- pheatmap::pheatmap(corrMat, show_rownames = F, show_colnames = F,
                   color = colorRampPalette(c('navy', 'white', 'red'))(100))
# ggsave(paste0(result_path, 'AG_Hell/metaPlasma_heatmap_feat_corr.png'), a,
#        device = 'png', dpi = 400)
```

Show only highly positively correlated feature pairs through network plot. Cutoff
is (1) correlations greater than 0.9 and (2) adjusted p-values less than 0.05.
```{r fig.height = 12, fig.width = 14}
# Prepare edge table
edges <- dplyr::mutate(corrMetaPlasmaRes_Hell,
                       Var1 = stringr::str_remove(Var1, '\\.x'),
                       Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  dplyr::filter(Corr > 0.9, pValAdj < 0.05, Var1 != Var2) %>%
  # Remove duplicated variable pairs
  dplyr::rowwise() %>%
  dplyr::mutate(varPair = paste(sort(c(Var1, Var2)), collapse = '')) %>%
  dplyr::distinct(varPair, .keep_all = T) %>%
  dplyr::select(Var1, Var2, Corr)

# Prepare node table
feats <- unique(c(edges$Var1, edges$Var2))
nodes <- data.frame(id = seq_len(length(feats)), Feature = feats)

# Map features to corresponding IDs
edges$Var1 <- plyr::mapvalues(edges$Var1, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)
edges$Var2 <- plyr::mapvalues(edges$Var2, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)

# Create igraph object for plotting
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

# Make network plot
ggraph(g, layout = 'fr') + #layout = 'auto'
  geom_edge_link(aes(alpha=Corr), edge_width = 1) +
  geom_node_point(size = 3, show.legend = F) +
  geom_node_text(aes(label=Feature), repel = T, size = 1.5) +
  theme_void() +
  scale_edge_alpha_continuous(name = 'Correlation') +
  scale_color_manual(values = c('black', 'firebrick'))
# ggsave(paste0(result_path, 'AG_Hell/metaPlasma_network_feat_corr.png'),
#        height = 10, width = 11, device = 'png', dpi = 400)
```

## Tissue Metabolites
<font size='5'> **Untargeted vs Targeted Tissue Metabolites** </font>\
Systematically compute correlations of all feature pairs where two features are
from paired datasets, i.e., Targeted and Untargeted Tissue Metabolomics. Note that
both Tumor and Normal samples were used.
<br/>
<br/>

Show correlations between features through heatmap
```{r}
# Load normalized data
metaTissue_Hopf <- readRDS('./data/AG_Hopf/metaTissueVsn.rds')
metaTissue_Hell <- readRDS('./data/AG_Hell/metaTissueNorm.rds')
# Extract data matrix
datMat_Hopf <- SummarizedExperiment::assay(metaTissue_Hopf)
datMat_Hell <- SummarizedExperiment::assay(metaTissue_Hell)
# Transpose data for systematically computing correlations between features
featTab_Hopf <- t(datMat_Hopf) %>%
  tibble::as_tibble(rownames = 'Sample')
featTab_Hell <- t(datMat_Hell) %>%
  tibble::as_tibble(rownames = 'Sample')

# Systematically compute correlations between untargeted feature pairs
# corrMetaTissueRes_Hopf_Hell <- corrIter(featTab_Hopf, featTab_Hell, cmn_col = 'Sample')
# saveRDS(corrMetaTissueRes_Hopf_Hell, './data/corrMetaTissueRes_Hopf_Hell.rds')
corrMetaTissueRes_Hopf_Hell <- readRDS('./data/corrMetaTissueRes_Hopf_Hell.rds')

# Convert long data to wide data
corrMat <- dplyr::select(corrMetaTissueRes_Hopf_Hell, Var1, Var2, Corr) %>%
  tidyr::pivot_wider(names_from = 'Var2', values_from = 'Corr') %>%
  tibble::column_to_rownames('Var1')

# Make heatmap
a <- pheatmap::pheatmap(corrMat, show_rownames = F, show_colnames = F,
                   color = colorRampPalette(c('navy', 'white', 'red'))(100),
                   breaks = seq(-1, 1, by = 0.02))
# ggsave(paste0(result_path, 'diffMethod_metaTissue_featCorr_heatmap.png'), a,
#        device = 'png', dpi = 400, height = 8, width = 10)
```

Show only highly positively correlated feature pairs through network plot. Cutoff
is (1) correlations greater than 0.9 and (2) p-values less than 0.05.
```{r fig.height = 12, fig.width = 14}
# Prepare edge table
edges <- dplyr::filter(corrMetaTissueRes_Hopf_Hell, Corr > 0.9, pVal < 0.05) %>%
  dplyr::select(Var1, Var2, Corr)

# Prepare node table
feats <- unique(c(edges$Var1, edges$Var2))
nodes <- data.frame(id = seq_len(length(feats)), Feature = feats,
                    From = c(rep('AG Hopf', length(unique(edges$Var1))),
                             rep('AG Hell', length(unique(edges$Var2)))))

# Map features in edge table to corresponding IDs
edges$Var1 <- plyr::mapvalues(edges$Var1, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)
edges$Var2 <- plyr::mapvalues(edges$Var2, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)
# Map Feature_ID from AG Hopf to m/z_RT
featAnno <- tibble::as_tibble(rowData(metaTissue_Hopf), rownames = 'Feature_ID')
nodes <- dplyr::mutate(nodes, Feature = plyr::mapvalues(Feature,
                                                        from = featAnno$Feature_ID,
                                                        to = featAnno$MZ.RT,
                                                        warn_missing = F))

# Create igraph object for plotting
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

# Make network plot
ggraph(g, layout = 'fr') + #layout = 'auto'
  geom_edge_link(aes(alpha=Corr), edge_width = 1) +
  geom_node_point(size = 3) +
  geom_node_text(aes(label=Feature, color=From), repel = T, size = 3.5) +
  theme_void() +
  scale_edge_alpha_continuous(name = 'Correlation') +
  scale_color_manual(values = c('firebrick', 'steelblue'))
# ggsave(paste0(result_path, 'diffMethod_metaTissue_featCorr_network.png'),
#        height = 9, width = 9, device = 'png', dpi = 400)
```

<font size='5'> **Untargeted Tissue Metabolites** </font>\
Systematically compute correlations of all feature pairs in Untargeted Tissue Metabolomics
<br/>
<br/>

**Use only Tumor samples to compute feature correlations**\
```{r}
# Load normalized data
metaTissue_Hopf <- readRDS('./data/AG_Hopf/metaTissueVsn.rds')
# Subset Tumor samples
tumorSmp <- colData(metaTissue_Hopf)[['Condition']] == 'Tumor'
metaTumor_Hopf <-metaTissue_Hopf[, tumorSmp]
# Extract data matrix
datMat <- SummarizedExperiment::assay(metaTumor_Hopf)
# Transpose data for systematically computing correlations between features
featTab <- t(datMat) %>%
  tibble::as_tibble(rownames = 'Sample')

# Systematically compute correlations between untargeted feature pairs
# corrMetaTumorRes_Hopf <- corrIter(featTab, featTab, cmn_col = 'Sample')
# saveRDS(corrMetaTumorRes_Hopf, './data/AG_Hopf/corrMetaTumorRes_Hopf.rds')
corrMetaTumorRes_Hopf <- readRDS('./data/AG_Hopf/corrMetaTumorRes_Hopf.rds')

# Convert long data to wide data
corrMat <- dplyr::select(corrMetaTumorRes_Hopf, Var1, Var2, Corr) %>%
  dplyr::mutate(Var1 = stringr::str_remove(Var1, '\\.x'),
                Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  tidyr::pivot_wider(names_from = 'Var2', values_from = 'Corr') %>%
  tibble::column_to_rownames('Var1')

# Make heatmap
# pheatmap::pheatmap(corrMat, show_rownames = F, show_colnames = F,
#                    color = colorRampPalette(c('navy', 'white', 'red'))(100))
```

Show highly positively correlated feature pairs through network plot. Cutoff is
(1) correlations greater than 0.99 and (2) adjusted p-values less than 0.05. Red
dots indicate significant features that can predict patient cancer recurrences
found in Tumor samples.
```{r fig.height = 12, fig.width = 14}
# Prepare node table
nodes <- data.frame(id = seq_len(nrow(datMat)),
                    Feature_ID = paste0('Feature', seq_len(nrow(datMat)))) %>%
  dplyr::mutate(Sig = dplyr::case_when(
    Feature_ID %in% proDAMetaTumorSigFeats$name ~ 'Yes',
    !Feature_ID %in% proDAMetaTumorSigFeats$name ~ 'No'))
# Append m/z_RT information
featAnno <- tibble::as_tibble(rowData(metaTumor_Hopf), rownames = 'Feature_ID')
nodes <- dplyr::left_join(nodes, featAnno, by = 'Feature_ID')

# Prepare edge table
edges <- dplyr::mutate(corrMetaTumorRes_Hopf,
                       Var1 = stringr::str_remove_all(Var1, '[Feature\\.x]'),
                       Var2 = stringr::str_remove_all(Var2, '[Feature\\.y]')) %>%
  dplyr::filter(Corr > 0.99, pValAdj < 0.05, Var1 != Var2) %>%
  # Remove duplicated variable pairs
  dplyr::rowwise() %>%
  dplyr::mutate(varPair = paste(sort(c(Var1, Var2)), collapse = '')) %>%
  dplyr::distinct(varPair, .keep_all = T) %>%
  dplyr::select(Var1, Var2, Corr)
# Remove nodes without any connection
incluFeats <- unique(c(edges$Var1, edges$Var2))
nodes <- nodes[nodes$id %in% incluFeats,]

# Create igraph object for plotting
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

# Make network plot
ggraph(g, layout = 'fr') + #layout = 'auto'
  geom_edge_link(aes(alpha=Corr), edge_width = 1) +
  geom_node_point(aes(color=Sig), size = 3, show.legend = F) +
  geom_node_text(aes(label=MZ.RT), repel = T, size = 1.5) +
  theme_void() +
  scale_edge_alpha_continuous(name = 'Correlation') +
  scale_color_manual(values = c('black', 'firebrick'))
# ggsave(paste0(result_path, 'AG_Hopf/metaTumor_network_feat_corr.png'),
#        height = 10, width = 11, device = 'png', dpi = 400)
```

**Use only Normal samples to compute feature correlations**\
```{r}
# Load normalized data
metaTissue_Hopf <- readRDS('./data/AG_Hopf/metaTissueVsn.rds')
# Subset Normal samples
normalSmp <- colData(metaTissue_Hopf)[['Condition']] == 'Normal'
metaNormal_Hopf <-metaTissue_Hopf[, normalSmp]
# Extract data matrix
datMat <- SummarizedExperiment::assay(metaNormal_Hopf)
# Transpose data for systematically computing correlations between features
featTab <- t(datMat) %>%
  tibble::as_tibble(rownames = 'Sample')

# Systematically compute correlations between untargeted feature pairs
# corrMetaNormalRes_Hopf <- corrIter(featTab, featTab, cmn_col = 'Sample')
# saveRDS(corrMetaNormalRes_Hopf, './data/AG_Hopf/corrMetaNormalRes_Hopf.rds')
corrMetaNormalRes_Hopf <- readRDS('./data/AG_Hopf/corrMetaNormalRes_Hopf.rds')

# Convert long data to wide data
corrMat <- dplyr::select(corrMetaNormalRes_Hopf, Var1, Var2, Corr) %>%
  dplyr::mutate(Var1 = stringr::str_remove(Var1, '\\.x'),
                Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  tidyr::pivot_wider(names_from = 'Var2', values_from = 'Corr') %>%
  tibble::column_to_rownames('Var1')

# Make heatmap
# pheatmap::pheatmap(corrMat, show_rownames = F, show_colnames = F,
#                    color = colorRampPalette(c('navy', 'white', 'red'))(100))
```

Show highly positively correlated feature pairs through network plot. Cutoff is
(1) correlations greater than 0.99 and (2) adjusted p-values less than 0.05. Red
dot indicates significant features that can predict patient cancer recurrences
found in Normal samples.
```{r fig.height = 12, fig.width = 14}
# Prepare node table
nodes <- data.frame(id = seq_len(nrow(datMat)),
                    Feature_ID = paste0('Feature', seq_len(nrow(datMat)))) %>%
  dplyr::mutate(Sig = dplyr::case_when(
    Feature_ID %in% proDAMetaNormalSigFeats$name ~ 'Yes',
    !Feature_ID %in% proDAMetaNormalSigFeats$name ~ 'No'))
# Append m/z_RT information
featAnno <- tibble::as_tibble(rowData(metaNormal_Hopf), rownames = 'Feature_ID')
nodes <- dplyr::left_join(nodes, featAnno, by = 'Feature_ID')

# Prepare edge table
edges <- dplyr::mutate(corrMetaNormalRes_Hopf,
                       Var1 = stringr::str_remove_all(Var1, '[Feature\\.x]'),
                       Var2 = stringr::str_remove_all(Var2, '[Feature\\.y]')) %>%
  dplyr::filter(Corr > 0.99, pValAdj < 0.05, Var1 != Var2) %>%
  # Remove duplicated variable pairs
  dplyr::rowwise() %>%
  dplyr::mutate(varPair = paste(sort(c(Var1, Var2)), collapse = '')) %>%
  dplyr::distinct(varPair, .keep_all = T) %>%
  dplyr::select(Var1, Var2, Corr)
# Remove nodes without any connection
incluFeats <- unique(c(edges$Var1, edges$Var2))
nodes <- nodes[nodes$id %in% incluFeats,]

# Create igraph object for plotting
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

# Make network plot
ggraph(g, layout = 'fr') + #layout = 'auto'
  geom_edge_link(aes(alpha=Corr), edge_width = 1) +
  geom_node_point(aes(color=Sig), size = 3, show.legend = F) +
  geom_node_text(aes(label=MZ.RT), repel = T, size = 1.5) +
  theme_void() +
  scale_edge_alpha_continuous(name = 'Correlation') +
  scale_color_manual(values = c('black', 'firebrick'))
# ggsave(paste0(result_path, 'AG_Hopf/metaNormal_network_feat_corr.png'),
#        height = 10, width = 11, device = 'png', dpi = 400)
```

**Use both Tumor and Normal Tissue samples to compute feature correlations**\
Show correlations between features through heatmap
```{r}
# Load normalized data
metaTissue_Hopf <- readRDS('./data/AG_Hopf/metaTissueVsn.rds')
# Extract data matrix
datMat <- SummarizedExperiment::assay(metaTissue_Hopf)
# Transpose data for systematically computing correlations between features
featTab <- t(datMat) %>%
  tibble::as_tibble(rownames = 'Sample')

# Systematically compute correlations between untargeted feature pairs
# corrMetaTissueRes_Hopf <- corrIter(featTab, featTab, cmn_col = 'Sample')
# saveRDS(corrMetaTissueRes_Hopf, './data/AG_Hopf/corrMetaTissueRes_Hopf.rds')
corrMetaTissueRes_Hopf <- readRDS('./data/AG_Hopf/corrMetaTissueRes_Hopf.rds')

# Convert long data to wide data
corrMat <- dplyr::select(corrMetaTissueRes_Hopf, Var1, Var2, Corr) %>%
  dplyr::mutate(Var1 = stringr::str_remove(Var1, '\\.x'),
                Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  tidyr::pivot_wider(names_from = 'Var2', values_from = 'Corr') %>%
  tibble::column_to_rownames('Var1')

# Make heatmap
a <- pheatmap::pheatmap(corrMat, show_rownames = F, show_colnames = F,
                   color = colorRampPalette(c('navy', 'white', 'red'))(100))
# ggsave(paste0(result_path, 'AG_Hopf/metaTissue_heatmap_feat_corr.png'), a,
#        device = 'png', dpi = 400)
```

Show only highly positively correlated feature pairs through network plot. Cutoff
is (1) correlations greater than 0.99 and (2) adjusted p-values less than 0.05.
```{r fig.height = 12, fig.width = 14}
# Prepare node table
nodes <- data.frame(id = seq_len(nrow(datMat)),
                    Feature_ID = paste0('Feature', seq_len(nrow(datMat))))
# Append m/z_RT information
featAnno <- tibble::as_tibble(rowData(metaTissue_Hopf), rownames = 'Feature_ID')
nodes <- dplyr::left_join(nodes, featAnno, by = 'Feature_ID')

# Prepare edge table
edges <- dplyr::mutate(corrMetaTissueRes_Hopf,
                       Var1 = stringr::str_remove_all(Var1, '[Feature\\.x]'),
                       Var2 = stringr::str_remove_all(Var2, '[Feature\\.y]')) %>%
  dplyr::filter(Corr > 0.99, pValAdj < 0.05, Var1 != Var2) %>%
  # Remove duplicated variable pairs
  dplyr::rowwise() %>%
  dplyr::mutate(varPair = paste(sort(c(Var1, Var2)), collapse = '')) %>%
  dplyr::distinct(varPair, .keep_all = T) %>%
  dplyr::select(Var1, Var2, Corr)
# Remove nodes without any connection
incluFeats <- unique(c(edges$Var1, edges$Var2))
nodes <- nodes[nodes$id %in% incluFeats,]

# Create igraph object for plotting
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

# Make network plot
ggraph(g, layout = 'fr') + #layout = 'auto'
  geom_edge_link(aes(alpha=Corr), edge_width = 1) +
  geom_node_point(size = 3, show.legend = F) +
  geom_node_text(aes(label=MZ.RT), repel = T, size = 1.5) +
  theme_void() +
  scale_edge_alpha_continuous(name = 'Correlation') +
  scale_color_manual(values = c('black', 'firebrick'))
# ggsave(paste0(result_path, 'AG_Hopf/metaTissue_network_feat_corr.png'),
#        height = 10, width = 11, device = 'png', dpi = 400)
```

<font size='5'> **Targeted Tissue Metabolites** </font>\
Systematically compute correlations of all feature pairs in Targeted Tissue Metabolomics
<br/>
<br/>

**Use only Tumor samples to compute feature correlations**\
```{r}
# Load normalized data
metaTissue_Hell <- readRDS('./data/AG_Hell/metaTissueNorm.rds')
# Subset Tumor samples
tumorSmp <- colData(metaTissue_Hell)[['Condition']] == 'Tumor'
metaTumor_Hell <- metaTissue_Hell[, tumorSmp]
# Extract data matrix
datMat <- SummarizedExperiment::assay(metaTumor_Hell)
# Transpose data for systematically computing correlations between features
featTab <- t(datMat) %>%
  tibble::as_tibble(rownames = 'Sample')

# Compute correlations
# corrMetaTumorRes_Hell <- corrIter(featTab, featTab, cmn_col = 'Sample')
# saveRDS(corrMetaTumorRes_Hell, paste0(result_path,
#                                       'AG_Hell/corrMetaTumorRes_Hell.rds'))
corrMetaTumorRes_Hell <- readRDS('./data/AG_Hell/corrMetaTumorRes_Hell.rds')

# Convert long data to wide data
corrMat <- dplyr::select(corrMetaTumorRes_Hell, Var1, Var2, Corr) %>%
  dplyr::mutate(Var1 = stringr::str_remove(Var1, '\\.x'),
                Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  tidyr::pivot_wider(names_from = 'Var2', values_from = 'Corr') %>%
  tibble::column_to_rownames('Var1')

# Make heatmap
# pheatmap::pheatmap(corrMat, show_rownames = F, show_colnames = F,
#                    color = colorRampPalette(c('navy', 'white', 'red'))(100))
```

Show highly positively correlated feature pairs through network plot. Cutoff is
(1) correlations greater than 0.9 and (2) adjusted p-values less than 0.05. Red
dot indicates significant features that can predict patient cancer recurrences
found in Tumor samples.
```{r fig.height = 12, fig.width = 14}
# Prepare edge table
edges <- dplyr::mutate(corrMetaTumorRes_Hell,
                       Var1 = stringr::str_remove(Var1, '\\.x'),
                       Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  dplyr::filter(Corr > 0.9, pValAdj < 0.05, Var1 != Var2) %>%
  # Remove duplicated variable pairs
  dplyr::rowwise() %>%
  dplyr::mutate(varPair = paste(sort(c(Var1, Var2)), collapse = '')) %>%
  dplyr::distinct(varPair, .keep_all = T) %>%
  dplyr::select(Var1, Var2, Corr)

# Prepare node table
# Conduct univariate analysis to obtain significant features that can potentially
# predict patient cancer recurrences
metaTumorRes_Hell <- SOA(metaTumor_Hell, factor = 'Recurrence')
feats <- unique(c(edges$Var1, edges$Var2))
nodes <- data.frame(id = seq_len(length(feats)), Feature = feats) %>%
  dplyr::mutate(Sig = dplyr::case_when(
    Feature %in% metaTumorRes_Hell$tFeatSigRes$Var1 ~ 'Yes',
    !Feature %in% metaTumorRes_Hell$tFeatSigRes$Var1 ~ 'No'))

# Map features to corresponding IDs
edges$Var1 <- plyr::mapvalues(edges$Var1, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)
edges$Var2 <- plyr::mapvalues(edges$Var2, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)

# Create igraph object for plotting
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

# Make network plot
ggraph(g, layout = 'fr') + #layout = 'auto'
  geom_edge_link(aes(alpha=Corr), edge_width = 1) +
  geom_node_point(aes(color=Sig), size = 3, show.legend = F) +
  geom_node_text(aes(label=Feature), repel = T, size = 1.5) +
  theme_void() +
  scale_edge_alpha_continuous(name = 'Correlation') +
  scale_color_manual(values = c('black', 'firebrick'))
# ggsave(paste0(result_path, 'AG_Hell/metaTumor_network_feat_corr.png'),
#        height = 10, width = 11, device = 'png', dpi = 400)
```

**Use only Normal samples to compute feature correlations**\
```{r}
# Load normalized data
metaTissue_Hell <- readRDS('./data/AG_Hell/metaTissueNorm.rds')
# Subset Normal samples
normalSmp <- colData(metaTissue_Hell)[['Condition']] == 'Normal'
metaNormal_Hell <- metaTissue_Hell[, normalSmp]
# Extract data matrix
datMat <- SummarizedExperiment::assay(metaNormal_Hell)
# Transpose data for systematically computing correlations between features
featTab <- t(datMat) %>%
  tibble::as_tibble(rownames = 'Sample')

# Compute correlations
# corrMetaNormalRes_Hell <- corrIter(featTab, featTab, cmn_col = 'Sample')
# saveRDS(corrMetaNormalRes_Hell, paste0(result_path,
#                                       'AG_Hell/corrMetaNormalRes_Hell.rds'))
corrMetaNormalRes_Hell <- readRDS('./data/AG_Hell/corrMetaNormalRes_Hell.rds')

# Convert long data to wide data
corrMat <- dplyr::select(corrMetaNormalRes_Hell, Var1, Var2, Corr) %>%
  dplyr::mutate(Var1 = stringr::str_remove(Var1, '\\.x'),
                Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  tidyr::pivot_wider(names_from = 'Var2', values_from = 'Corr') %>%
  tibble::column_to_rownames('Var1')

# Make heatmap
# pheatmap::pheatmap(corrMat, show_rownames = F, show_colnames = F,
#                    color = colorRampPalette(c('navy', 'white', 'red'))(100))
```

Show highly positively correlated feature pairs through network plot. Cutoff is
(1) correlations greater than 0.9 and (2) adjusted p-values less than 0.05. Red
dot indicates significant features that can predict patient cancer recurrences
found in Normal samples.
```{r fig.height = 12, fig.width = 14}
# Prepare edge table
edges <- dplyr::mutate(corrMetaNormalRes_Hell,
                       Var1 = stringr::str_remove(Var1, '\\.x'),
                       Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  dplyr::filter(Corr > 0.9, pValAdj < 0.05, Var1 != Var2) %>%
  # Remove duplicated variable pairs
  dplyr::rowwise() %>%
  dplyr::mutate(varPair = paste(sort(c(Var1, Var2)), collapse = '')) %>%
  dplyr::distinct(varPair, .keep_all = T) %>%
  dplyr::select(Var1, Var2, Corr)

# Prepare node table
# Conduct univariate analysis to obtain significant features that can potentially
# predict patient cancer recurrences
metaNormalRes_Hell <- SOA(metaNormal_Hell, factor = 'Recurrence')
feats <- unique(c(edges$Var1, edges$Var2))
nodes <- data.frame(id = seq_len(length(feats)), Feature = feats) %>%
  dplyr::mutate(Sig = dplyr::case_when(
    Feature %in% metaNormalRes_Hell$tFeatSigRes$Var1 ~ 'Yes',
    !Feature %in% metaNormalRes_Hell$tFeatSigRes$Var1 ~ 'No'))

# Map features to corresponding IDs
edges$Var1 <- plyr::mapvalues(edges$Var1, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)
edges$Var2 <- plyr::mapvalues(edges$Var2, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)

# Create igraph object for plotting
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

# Make network plot
ggraph(g, layout = 'fr') + #layout = 'auto'
  geom_edge_link(aes(alpha=Corr), edge_width = 1) +
  geom_node_point(aes(color=Sig), size = 3, show.legend = F) +
  geom_node_text(aes(label=Feature), repel = T, size = 1.5) +
  theme_void() +
  scale_edge_alpha_continuous(name = 'Correlation') +
  scale_color_manual(values = c('black', 'firebrick'))
# ggsave(paste0(result_path, 'AG_Hell/metaNormal_network_feat_corr.png'),
#        height = 10, width = 11, device = 'png', dpi = 400)
```

**Use both Tumor and Normal Tissue samples to compute feature correlations**\
Show correlations between features through heatmap
```{r}
# Load normalized data
metaTissue_Hell <- readRDS('./data/AG_Hell/metaTissueNorm.rds')
# Extract data matrix
datMat <- SummarizedExperiment::assay(metaTissue_Hell)
# Transpose data for systematically computing correlations between features
featTab <- t(datMat) %>%
  tibble::as_tibble(rownames = 'Sample')

# Compute correlations
# corrMetaTissueRes_Hell <- corrIter(featTab, featTab, cmn_col = 'Sample')
# saveRDS(corrMetaTissueRes_Hell, paste0(result_path, 'AG_Hell/corrMetaTissueRes_Hell.rds'))
corrMetaTissueRes_Hell <- readRDS('./data/AG_Hell/corrMetaTissueRes_Hell.rds')

# Convert long data to wide data
corrMat <- dplyr::select(corrMetaTissueRes_Hell, Var1, Var2, Corr) %>%
  dplyr::mutate(Var1 = stringr::str_remove(Var1, '\\.x'),
                Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  tidyr::pivot_wider(names_from = 'Var2', values_from = 'Corr') %>%
  tibble::column_to_rownames('Var1')

# Make heatmap
a <- pheatmap::pheatmap(corrMat, show_rownames = F, show_colnames = F,
                   color = colorRampPalette(c('navy', 'white', 'red'))(100))
# ggsave(paste0(result_path, 'AG_Hell/metaTissue_heatmap_feat_corr.png'), a,
#        device = 'png', dpi = 400)
```

Show only highly positively correlated feature pairs through network plot. Cutoff
is (1) correlations greater than 0.9 and (2) adjusted p-values less than 0.05.
```{r fig.height = 12, fig.width = 14}
# Prepare edge table
edges <- dplyr::mutate(corrMetaTissueRes_Hell,
                       Var1 = stringr::str_remove(Var1, '\\.x'),
                       Var2 = stringr::str_remove(Var2, '\\.y')) %>%
  dplyr::filter(Corr > 0.9, pValAdj < 0.05, Var1 != Var2) %>%
  # Remove duplicated variable pairs
  dplyr::rowwise() %>%
  dplyr::mutate(varPair = paste(sort(c(Var1, Var2)), collapse = '')) %>%
  dplyr::distinct(varPair, .keep_all = T) %>%
  dplyr::select(Var1, Var2, Corr)

# Prepare node table
feats <- unique(c(edges$Var1, edges$Var2))
nodes <- data.frame(id = seq_len(length(feats)), Feature = feats)

# Map features to corresponding IDs
edges$Var1 <- plyr::mapvalues(edges$Var1, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)
edges$Var2 <- plyr::mapvalues(edges$Var2, from = nodes$Feature, to = nodes$id,
                              warn_missing = F)

# Create igraph object for plotting
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

# Make network plot
ggraph(g, layout = 'fr') + #layout = 'auto'
  geom_edge_link(aes(alpha=Corr), edge_width = 1) +
  geom_node_point(size = 3, show.legend = F) +
  geom_node_text(aes(label=Feature), repel = T, size = 1.5) +
  theme_void() +
  scale_edge_alpha_continuous(name = 'Correlation') +
  scale_color_manual(values = c('black', 'firebrick'))
# ggsave(paste0(result_path, 'AG_Hell/metaTissue_network_feat_corr.png'),
#        height = 10, width = 11, device = 'png', dpi = 400)
```
1. The overall correlation between Targeted and Untargeted features is not that
high. Two possibilities: (1) two methods capture different information from the
samples, which means they can be complementary to each other, or (2) there are
some inherent biological or technical noises, which leads to inaccurate data.
2. There are much more highly correlated feature clusters in the Targeted Metabolomics,
maybe because a large number of the Targeted features are derivatives of Triglycerides,
Diglycerides, etc.
3. Tissue Metabolomics, both Targeted and Untargeted, has much more highly correlated
(correlation > 0.9) feature clusters than Plasma Metabolomics.



# Sth else

## Recurrence-related features

Display proportion of significant features that can potentially predict patient
cancer recurrences from the following datasets. Associations between features and
cancer recurrence are tested by t-test, comparing feature means of recurrence and
non-recurrence patient groups.
```{r}
cat(paste(nrow(metaBaseRes_Hell$tFeatSigRes), 'out of', nrow(metaBaseRes_Hell$data),
          'features in Targeted Plasma Metabolomics, and\n',
          nrow(proDAMetaBaseSigFeats), 'out of', nrow(metaBaseRes_Hopf$data),
          'features in Untargeted Plasma Metabolomics, and\n',
          nrow(metaTumorRes_Hell$tFeatSigRes), 'out of', nrow(metaTumorRes_Hell$data),
          'features in Targeted Tumor Metabolomics, and\n',
          nrow(proDAMetaTumorSigFeats), 'out of', nrow(metaTumorRes_Hopf$data),
          'features in Untargeted Tumor Metabolomics, and\n',
          nrow(metaNormalRes_Hell$tFeatSigRes), 'out of', nrow(metaNormalRes_Hell$data),
          'features in Targeted Normal Metabolomics, and\n',
          nrow(proDAMetaNormalSigFeats), 'out of', nrow(metaNormalRes_Hopf$data),
          'features in Untargeted Normal Metabolomics can significantly predict',
          'patient cancer recurrences.'))

# Make barplot
# Compute proportion of significant features
# Compute proportion of significant features
metaBaseSigFeats_Hell <- nrow(metaBaseRes_Hell$tFeatSigRes) / nrow(metaBaseRes_Hell$data) * 100
metaBaseSigFeats_Hopf <- nrow(proDAMetaBaseSigFeats) / nrow(metaBaseRes_Hopf$data) * 100
metaTumorSigFeats_Hell <- nrow(metaTumorRes_Hell$tFeatSigRes) / nrow(metaTumorRes_Hell$data) * 100
metaTumorSigFeats_Hopf <- nrow(proDAMetaTumorSigFeats) / nrow(metaTumorRes_Hopf$data) * 100
metaNormalSigFeats_Hell <- nrow(metaNormalRes_Hell$tFeatSigRes) / nrow(metaNormalRes_Hell$data) * 100
metaNormalSigFeats_Hopf <- nrow(proDAMetaNormalSigFeats) / nrow(metaNormalRes_Hopf$data) * 100

dat <- rev(c(rep('Baseline Plasma Metabolomics', 2),
             rep('Tumor Tissue Metabolomics', 2),
             rep('Normal Tissue Metabolomics', 2)))
method <- rev(rep(c('Targeted', 'Untargeted'), 3))
proportion <- rev(c(metaBaseSigFeats_Hell, metaBaseSigFeats_Hopf,
                    metaTumorSigFeats_Hell, metaTumorSigFeats_Hopf,
                    metaNormalSigFeats_Hell, metaNormalSigFeats_Hopf))
sigFeatPropTab <- data.frame(Data = factor(dat, levels = unique(dat)),
                             Method = method,
                             Proportion = proportion)

ggplot(sigFeatPropTab, aes(x=Data, y=Proportion, fill=Method)) +
  geom_bar(stat = 'identity', position = position_dodge()) +
  labs(y = 'Percentage (%)',
       title = 'Proportion of Cancer Recurrence-Related Features') +
  coord_flip() +
  scale_fill_discrete(name = 'Method') +
  theme(axis.title = element_text(size = 16), axis.text = element_text(size = 12),
        legend.title = element_text(size = 14), legend.text = element_text(size = 12))
# ggsave(paste0(result_path, 'diffMethod_proporSigFeats.png'), device = 'png', dpi = 400,
#        height = 8, width = 10)
```

## MOFA
Leverage MOFA model to observe if there are same sources of variation across data
of same modality but generated by different methods (e.g., Targeted Plasma Metabolomics
vs Untargeted Plasma Metabolomics). If there exist, it means that two methods partially
capture similar information from samples.

```{r}
# Plasma metabolomics (Hell)
metaPlasma_Hell <- readRDS('./data/AG_Hell/metaPlasmaNorm.rds')
# Plasma metabolomics (Hopf)
metaPlasma_Hopf <- readRDS('./data/AG_Hopf/metaPlasmaVsn.rds')
# Tissue metabolomics (Hell)
metaTissue_Hell <- readRDS('./data/AG_Hell/metaTissueNorm.rds')
# Tissue metabolomics (Hopf)
metaTissue_Hopf <- readRDS('./data/AG_Hopf/metaTissueVsn.rds')

# Convert SE objects to long data for creating MOFA object through
# 'create_mofa_from_df' to include metadata
# Plasma metabolomics (Hell)
metaPlasmaTab_Hell <- summExp2df(metaPlasma_Hell, row_id = 'feature', col_id = 'sample') %>%
  dplyr::select(-Identifier) %>%
  dplyr::rename(value = Value) %>%
  dplyr::mutate(view = 'Targeted Metabolomics',
                group = dplyr::case_when(Condition == 'Baseline' ~ 'Baseline Plasma',
                                         Condition != 'Baseline' ~ 'Follow-up Plasma'))
# Plasma metabolomics (Hopf)
metaPlasmaTab_Hopf <- summExp2df(metaPlasma_Hopf, row_id = 'feature', col_id = 'sample') %>%
  dplyr::select(-m.z_RT) %>%
  dplyr::rename(value = Value) %>%
  dplyr::mutate(sample = dplyr::case_when(Condition == 'Baseline' ~ paste0(Patient, '_P_B'),
                                          Condition != 'Baseline' ~ paste0(Patient, '_P_R')),
    view = 'Untargeted Metabolomics',
    group = dplyr::case_when(Condition == 'Baseline' ~ 'Baseline Plasma',
                             Condition != 'Baseline' ~ 'Follow-up Plasma'))
# Tissue metabolomics (Hell)
metaTissueTab_Hell <- summExp2df(metaTissue_Hell, row_id = 'feature', col_id = 'sample') %>%
  dplyr::select(-Identifier) %>%
  dplyr::rename(value = Value) %>%
  dplyr::mutate(view = 'Targeted Metabolomics',
                group = dplyr::case_when(Condition == 'Tumor' ~ 'Tumor Tissue',
                                         Condition == 'Normal' ~ 'Normal Tissue'))
# Tissue metabolomics (Hopf)
metaTissueTab_Hopf <- summExp2df(metaTissue_Hopf, row_id = 'feature', col_id = 'sample') %>%
  dplyr::select(-MZ.RT) %>%
  dplyr::rename(value = Value) %>%
  dplyr::mutate(view = 'Untargeted Metabolomics',
                group = dplyr::case_when(Condition == 'Tumor' ~ 'Tumor Tissue',
                                         Condition == 'Normal' ~ 'Normal Tissue'))
```

<font size='5'> **Plasma Metabolomics** </font>\
Training data: Targeted and Untargeted Plasma Metabolomics
```{r}
# Create MOFA object
# Concatenate long data
summPlasmaTab <- dplyr::bind_rows(metaPlasmaTab_Hell, metaPlasmaTab_Hopf)
mofaPlasmaObject <- MOFA2::create_mofa_from_df(summPlasmaTab, extract_metadata = T)
# Overview data in MOFA object
plot_data_overview(mofaPlasmaObject)

# Train MOFA model
# data_opts <- get_default_data_options(mofaPlasmaObject)
# model_opts <- get_default_model_options(mofaPlasmaObject)
# model_opts$num_factors <- 10
# train_opts <- get_default_training_options(mofaPlasmaObject)
# train_opts$convergence_mode <- 'slow'
# 
# mofaPlasmaObject <- prepare_mofa(mofaPlasmaObject,
#                                  data_options = data_opts,
#                                  model_options = model_opts,
#                                  training_options = train_opts)
# 
# mofaPlasmaObject <- run_mofa(mofaPlasmaObject,
#                              outfile = './data/mofa/co_metaPlasma_mofa_10Fac.hdf5',
#                              use_basilisk = F)
# saveRDS(mofaPlasmaObject, './data/mofa/co_metaPlasma_mofa_10Fac.rds')


# Load trained MOFA model
mofaPlasmaObject <- readRDS('./data/mofa/co_metaPlasma_mofa_10Fac.rds')

# Do sanity check for factor correlations
# MOFA2::plot_factor_cor(mofaPlasmaObject)

# Perform variance dedecomposition analysis (coefficient of determination)
MOFA2::plot_variance_explained(mofaPlasmaObject, max_r2 = 15) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# Conduct association test between learnt factors and cancer recurrence
facTab <- tibble::as_tibble(get_factors(mofaPlasmaObject)[['Baseline Plasma']],
                            rownames = 'sample')
metaTab <- tibble::as_tibble(samples_metadata(mofaPlasmaObject)) %>%
  dplyr::filter(Condition == 'Baseline') %>%
  dplyr::select(sample, Recurrence)
tBaseRes <- tTestIter(facTab, metaTab, cmn_col = 'sample') %>%
  dplyr::filter(pVal <= 0.05) %>%
  dplyr::select(-c('Group1', 'Group2', 'Mu1', 'Mu2'))
# tBaseRes
```

<font size='5'> **Tissue Metabolomics** </font>\
Training data: Targeted and Untargeted Tissue Metabolomics
```{r}
# Create MOFA object
# Concatenate long data
summTissueTab <- dplyr::bind_rows(metaTissueTab_Hell, metaTissueTab_Hopf)
mofaTissueObject <- MOFA2::create_mofa_from_df(summTissueTab, extract_metadata = T)
# Overview data in MOFA object
plot_data_overview(mofaTissueObject)

# Train MOFA model
# data_opts <- get_default_data_options(mofaTissueObject)
# model_opts <- get_default_model_options(mofaTissueObject)
# model_opts$num_factors <- 10
# train_opts <- get_default_training_options(mofaTissueObject)
# train_opts$convergence_mode <- 'slow'
# 
# mofaTissueObject <- prepare_mofa(mofaTissueObject,
#                                  data_options = data_opts,
#                                  model_options = model_opts,
#                                  training_options = train_opts)
# 
# mofaTissueObject <- run_mofa(mofaTissueObject,
#                              outfile = './data/mofa/co_metaTissue_mofa_10Fac.hdf5',
#                              use_basilisk = F)
# saveRDS(mofaTissueObject, './data/mofa/co_metaTissue_mofa_10Fac.rds')


# Load trained MOFA model
mofaTissueObject <- readRDS('./data/mofa/co_metaTissue_mofa_10Fac.rds')

# Do sanity check for factor correlations
# MOFA2::plot_factor_cor(mofaTissueObject)

# Perform variance dedecomposition analysis (coefficient of determination)
MOFA2::plot_variance_explained(mofaTissueObject, max_r2 = 15) +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5, size = 11),
        text = element_text(size = 14))
# ggsave(paste0(result_path, 'diffMethod_metaTissue_varExplained_mofa.png'),
#        height = 8, width = 10, device = 'png', dpi = 400)

# Conduct association test between learnt factors and cancer recurrence
# Tumor Tissue Group
facTab <- tibble::as_tibble(get_factors(mofaTissueObject)[['Tumor Tissue']],
                            rownames = 'sample')
metaTab <- tibble::as_tibble(samples_metadata(mofaTissueObject)) %>%
  dplyr::filter(Condition == 'Tumor') %>%
  dplyr::select(sample, Recurrence)
tTumorRes <- tTestIter(facTab, metaTab, cmn_col = 'sample') %>%
  dplyr::filter(pVal <= 0.05) %>%
  dplyr::select(-c('Group1', 'Group2', 'Mu1', 'Mu2'))
# tTumorRes
# Normal Tissue Group
facTab <- tibble::as_tibble(get_factors(mofaTissueObject)[['Normal Tissue']],
                            rownames = 'sample')
metaTab <- tibble::as_tibble(samples_metadata(mofaTissueObject)) %>%
  dplyr::filter(Condition == 'Normal') %>%
  dplyr::select(sample, Recurrence)
tNormalRes <- tTestIter(facTab, metaTab, cmn_col = 'sample') %>%
  dplyr::filter(pVal <= 0.05) %>%
  dplyr::select(-c('Group1', 'Group2', 'Mu1', 'Mu2'))
# tNormalRes
```
=> The MOFA models capture few factors that slightly explain the same sources of
variation across Targeted and Untargeted Plasma (e.g., Factor4) or Tissue (e.g.,
Factor10) Metabolomics. To sum up, Targeted and Untargeted datasets have some
similarities but not much.


```{r include = F, eval = F}
# Display overlaps of potential features that could predict cancer recurrences. To
# be clearer, feature lists obtained from association test (t-test) results and PCA
# results were taken to make venn plots. Notice that t-test and PCA got different
# feature space due to whether missing data is allowed, i.e., features with missing
# values are removed to conduct PCA, which may make venn plots associated with
# Untargeted datasets misleading.

# BPM
# Prepare feature lists
# Targeted Plasma Metabolomics
sigFeats_Hell <- metaBaseRes_Hell$tFeatSigRes$Var1
topFeats_PC11_Hell <- metaBaseRes_Hell$pcTopFeatTab$PC11$Feature
topFeats_PC15_Hell <- metaBaseRes_Hell$pcTopFeatTab$PC15$Feature
# Untargeted Plasma Metabolomics
sigFeats_Hopf <- metaBaseRes_Hopf$tFeatSigRes$Var1
topFeats_Hopf <- metaBaseRes_Hopf$pcTopFeatTab$PC5$Feature

# Make venn plots
# Targeted Plasma Metabolomics
ggVennDiagram(list(sigFeats_Hell, topFeats_PC11_Hell, topFeats_PC15_Hell),
              category.names = c('Ori.', 'PC11', 'PC15'),
              set_size = 8,
              label = 'count',
              label_alpha = 0,
              label_size = 12,
              edge_lty = 'blank') +
  labs(title = 'Targeted Plasma Metabolomics') +
  theme_void()

# Untargeted Plasma Metabolomics
ggVennDiagram(list(sigFeats_Hopf, topFeats_Hopf),
              category.names = c('Sig. Features', 'PC Top Features'),
              set_size = 8,
              label = 'count',
              label_alpha = 0,
              label_size = 12,
              edge_lty = 'blank') +
  labs(title = 'Untargeted Plasma Metabolomics') +
  theme_void()


# TTM and NTM
# Prepare feature lists
# Targeted Tissue Metabolomics
sigTumorFeats_Hell <- metaTumorRes_Hell$tFeatSigRes$Var1
sigNormalFeats_Hell <- metaNormalRes_Hell$tFeatSigRes$Var1
topTumorFeats_Hell <- metaTumorRes_Hell$pcTopFeatTab$PC16$Feature
topNormalFeats_PC6_Hell <- metaNormalRes_Hell$pcTopFeatTab$PC6$Feature
topNormalFeats_PC17_Hell <- metaNormalRes_Hell$pcTopFeatTab$PC17$Feature
topNormalFeats_PC9_Hell <- metaNormalRes_Hell$pcTopFeatTab$PC9$Feature
# Untargeted Plasma Metabolomics
sigTumorFeats_Hopf <- metaTumorRes_Hopf$tFeatSigRes$Var1
sigNormalFeats_Hopf <- metaNormalRes_Hopf$tFeatSigRes$Var1
topTumorFeats_Hopf <- metaTumorRes_Hopf$pcTopFeatTab$PC6$Feature


# Make venn plots
# Targeted Tissue Metabolomics
ggVennDiagram(list(sigTumorFeats_Hell, sigNormalFeats_Hell),
              category.names = c('Tumor', 'Normal'),
              set_size = 6,
              label = 'count',
              label_alpha = 0,
              label_size = 12,
              edge_lty = 'blank') +
  labs(title = 'Significant features of Targeted Tissue Metabolomics') +
  theme_void()

ggVennDiagram(list(sigTumorFeats_Hell, topTumorFeats_Hell),
              category.names = c('Sig. Features', 'PC16'),
              set_size = 8,
              label = 'count',
              label_alpha = 0,
              label_size = 12,
              edge_lty = 'blank') +
  labs(title = 'Targeted Tumor Tissue Metabolomics') +
  theme_void()

ggVennDiagram(list(sigNormalFeats_Hell, topNormalFeats_PC6_Hell,
                   topNormalFeats_PC17_Hell, topNormalFeats_PC9_Hell),
              category.names = c('Sig. Features', 'PC6', '17', 'PC9'),
              set_size = 4,
              label = 'count',
              label_alpha = 0,
              label_size = 12,
              edge_lty = 'blank') +
  labs(title = 'Targeted Normal Tissue Metabolomics') +
  theme_void()

# Untargeted Tissue Metabolomics
ggVennDiagram(list(sigTumorFeats_Hopf, sigNormalFeats_Hopf),
              category.names = c('Tumor', 'Normal'),
              set_size = 6,
              label = 'count',
              label_alpha = 0,
              label_size = 12,
              edge_lty = 'blank') +
  labs(title = 'Significant features of Untargeted Tissue Metabolomics') +
  theme_void()

# Same size of significant feature list and significant PC feature lists:
# Targeted Tumor (8) and Normal (5) Tissue Metabolomics got no overlap. Targeted
# Differential (4) Tissue Metabolomics got 1 overlaps.
```
